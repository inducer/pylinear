\chapter{The \class{Array} types}
\begin{quote}
   This chapter decribes the basic array types provided by PyLinear, and
   the elementary operations available on them.
\end{quote}

The present chapter describes the module \module{pylinear.array}. It is
assumed to be imported using
\begin{verbatim}
>>> from pylinear.array import *
\end{verbatim}
in the examples.

PyLinear provides four flavors of arrays with two different element
types each.  The possible \dfn{flavors}\index{flavor} are:
\begin{itemize}
  \item dense vector\indexii{Dense}{Vector},
  \item dense matrix\indexii{Dense}{Matrix},
  \item sparse build matrix\indexiii{Sparse}{Build}{Matrix}, and
  \item sparse execute matrix\indexiii{Sparse}{Execute}{Matrix}.
\end{itemize}
From this point onwards, we will use the term \class{Array}\index{array}
to mean any type of matrix or vector. The term \class{Matrix}\index{matrix}
will refer to any of the matrix types. The term \class{Vector}\index{vector}
shall refer to only the dense vector type. Note that these do not exist as
classes as such, but we will pretend that they do.

The supported element types are
\begin{itemize}
  \item double precision (i.e. 64-bit) real, and
  \item double precision (i.e. 2x64-bit) complex.
\end{itemize}

PyLinear only allows vectors and matrices (i.e.  objects with one and
two index dimensions, but no tensors or other higher-dimensional
objects). There is only one vector flavor, but there are three
different flavors of matrices with different performance and memory
characteristics. \emph{Dense} matrices store \var{m}-by-\var{n}
elements in a two-dimensional grid of \var{m} rows and \var{n}
columns. They are used for small matrices or those which have mostly
non-zero elements. Contrast this with the sparse types, which are
typically used for matrices consisting of mostly zero
elements. \emph{Sparse build} matrices store their elements a list of
\samp{(i, j, a[i,j])}, to which new elements are simply appended,
which is very fast. This list is typically unsorted, but may have to
be sorted by \var{i} and \var{j} for multiplication, element access or
element removal, which makes these operations pretty
slow. Consequently, this flavor is typically used for the assembly of
large sparse matrices. It is then converted to the \emph{sparse
execute} flavor for fast matrix multiplication. This flavor uses a
standard compressed column format for fast linear algebra operations.

Each of the flavors is represented by a symbolic constant:

\begin{tableii}{l|l}{constant}{Constant}{Corresponding Flavor}
  \lineii{Vector}
         {Specifies the dense vector flavor.}
  \lineii{DenseMatrix}
         {Specifies the dense matrix flavor.}
  \lineii{SparseBuildMatrix}
         {Specifies the sparse build matrix flavor.}
  \lineii{SparseExecuteMatrix}
         {Specifies the sparse execute matrix flavor.}
\end{tableii}

Likewise, each of the element types has its own symbolic constant.
These constants are usually called \indexii{type}{code}\index{typecode}\dfn{typecodes}.

\begin{tableii}{l|l}{constant}{Constant}{Corresponding Element Type}
  \lineii{Float64}
         {Specifies the 64-bit real element type.}
  \lineii{Complex64}
         {Specifies the 2x64-bit complex element type.}
  \lineii{Float}
         {Specifies the machine-native C++ \ctype{double} element type.
          Currently an alias for \constant{Float64}.}
  \lineii{Complex}
         {Specifies the machine-native C++ \ctype{std::complex<double>} 
          element type. Currently an alias for \constant{Complex64}.}
\end{tableii}

Despite some dissimilarity, PyLinear's matrix layer attempts to be
mostly compatible with Numerical Python.

% --------------------------------------------------------------------------
\section{Creating \class{Array}s}

The following functions in the module \module{pylinear.array} permit
the creation of new \class{Array}s:

\begin{funcdesc}{array}{sequence, typecode=None}
   There are many ways to create arrays. The most basic one is the use of the
   \function{array} function:
\begin{verbatim}
>>> a = array([1.2, 3.5, -1])
\end{verbatim}
   to make sure this worked, do:
\begin{verbatim}
>>> print a
[3](1.2,3.5,-1)
\end{verbatim}
   The \function{array} function takes several arguments --- the first
   one is the values, which can be a Python sequence object (such as a
   list or a tuple).  The optional argument \code{type} specifies the
   element type of the matrix. If omitted, as in the example above,
   Python tries to find the best data type which can represent all the
   elements. \function{array} always creates dense matrices or
   vectors, depending on the \dfn{dimensionality}\index{dimension} of
   the input data.  (The dimension of the data is 1 for a list, 2 for a
   list of lists, and so on.  1-dimensional data will be converted to
   vectors, 2-dimensional data to matrices.)
   
   Since the elements we gave our example were two floats and one integer, it
   chose \class{Float64} as the type of the resulting array. One can specify
   unequivocally the \code{type} of the elements---this is especially 
   useful when, for example, one wants an array contains complex numbers even
   though all of its input elements are reals:
\begin{verbatim}
>>> x,y,z = 1,2,3
>>> a = array([x,y,z])                  # reals are enough for 1, 2 and 3
[3](1,2,3)
>>> print a
>>> a = array([x,y,z], type=Complex64)    # not the default type
>>> print a
[3]((1,0),(2,0),(3,0))
\end{verbatim}
    Note that in NumPy, \function{array} takes a few more arguments, such as
    \code{copy}, \code{savespace}, and \code{shape}. These are not supported.
\end{funcdesc}

\begin{funcdesc}{sparse}{mapping, shape=None, typecode=None, flavor=SparseBuildMatrix}
  This function creates a (not necessarily sparse) \class{Matrix} of
  the given \code{shape}, \code{typecode}, and \code{flavor} based on
  a sparse representation its entries. At present, it cannot create
  \class{Vector}s. The sparse representation consists of a dictionary
  of dictionaries, whose keys are the row indices for the outer dictionary,
  and the column indices for the inner one.

  If the \code{shape} parameter is unspecified, the shape is specified by
  the largest row and column indices seen in examining the \code{mapping}.
  If the \code{typecode} is unspecified, \function{sparse} uses the same
  logic as \function{data} to determine it.
\end{funcdesc}

\begin{funcdesc}{asarray}{seq, typecode, flavor = None}
  This function converts scalars, lists and tuples to an
  \class{Array} type, if possible. It passes \class{Array}s through,
  making copies only to convert types.  In any other case a
  \class{TypeError} is raised.
\end{funcdesc}

\begin{funcdesc}{zeros}{shape, typecode, flavor = None}
  \function{zeros} creates an \class{Array} of the given \var{shape},
  \var{typecode} and \var{flavor} which is filled with zeros. See the
  \member{shape} attribute in Section \ref{sec:arrayproperties} for
  information on the \var{shape} parameter.
\end{funcdesc}

\begin{funcdesc}{ones}{shape, typecode, flavor = None}
  \function{ones} creates an \class{Array} of the given \var{shape},
  \var{typecode} and \var{flavor} which is filled with ones. See the
  \member{shape} attribute in Section \ref{sec:arrayproperties} for
  information on the \var{shape} parameter.
\end{funcdesc}

\begin{funcdesc}{identity}{n, typecode, flavor = None}
  \function{identity} creates a \class{Matrix} of shape \code{(n,n)} and
  the given \var{typecode} and \var{flavor} which is filled with
  zeros and has ones on the diagonal, a type of matrix otherwise
  known as an identity matrix.
\end{funcdesc}

\class{Array}s also have efficient support for pickling. So, unpickling
a previously pickled \class{Array} is another way to create one.

% --------------------------------------------------------------------------
\section{Accessing \class{Array} properties}

\label{sec:arrayproperties}
An \class{Array} has the following meta-data attributes:

\begin{memberdesc}[Array]{shape}
  Reading the \member{shape} attribute gets the shape tuple, that is,
  a tuple of length equal to the array's dimension specifying the
  dimensions of the matrix.  For a vector, this is a singleton
  containing an integer, for a matrix, this is a pair containing the
  number of rows and columns, in this order.  

  Assigning a value to the \member{shape} attribute will destructively
  resize the array.
\end{memberdesc}

\begin{memberdesc}[Array]{flavor}
  Reading the \member{flavor} attribute gets the flavor of the given
  matrix. Assigning a value to the \member{flavor} attribute is not supported.
\end{memberdesc}

An \class{Array} has the following meta-data-returning methods:

\begin{methoddesc}[Array]{typecode}{}
  Returns the typecode of the matrix.
\end{methoddesc}

% --------------------------------------------------------------------------
\section{Accessing and modifying \class{Array} data}

An \class{Array} has the following data attributes:

\begin{memberdesc}[Array]{real}
  Reading this attribute obtains a copy of the real part of the matrix.
  For real matrices, the matrix is simply copied.

  Returns a view, not a copy, in NumPy. Only on complex arrays in NumPy.
\end{memberdesc}

\begin{memberdesc}[Array]{imaginary}
  Reading this attribute obtains a copy of the imaginary part of the matrix.
  For real matrices, a zero matrix of the same size is returned.

  Returns a view, not a copy, in NumPy. Only on complex arrays in NumPy.
\end{memberdesc}

In addition to the \class{Array} data attributes, \class{Matrix} types
offer the following:

\begin{memberdesc}[Matrix]{T}
  Returns a real-transpose copy of the matrix.

  Does not exist in NumPy.
\end{memberdesc}

\begin{memberdesc}[Matrix]{H}
  Returns a conjugate-transpose copy of the matrix.
  Identical to \member{T} for real matrices.

  Does not exist in NumPy.
\end{memberdesc}

Naturally, PyLinear will also support indexing for reading and writing
on \class{Array}s. Typically, matrices are indexed by 2-tuples,
whereas vectors are indexed by single values. Indexing a matrix with a
single value will return the entire row. Regular Python slice syntax
is supported, so that you can write \code{a[3:17]}, \code{a[1:3,5:9]},
or even \code{a[::-1]}. Unlike Python lists, \class{Array}s may not be
resized using slice assignments. Like in the rest of Python, yet
unlike NumPy, slices return copies, not views of the corresponding
data.

The following methods are available on PyLinear's \class{Array} types:
% XXX sum
% abs_square_sum intentionally undocumented
% XXX iter
% XXX indices
% XXX add_scattered
% XXX copy
% XXX sort
% XXX set_element
% XXX add_element
% XXX set_element_past_end
% XXX complete_index1_data

PyLinear also supports a number of data access functions that resemble
NumPy's functionality and are there mainly to ease porting:

\begin{funcdesc}{diagonal}{matrix, offset=0}
  Returns the diagonal of \var{matrix} as a vector, or the \var{offset}th
  super- (for \code{offset>0}) or sub-diagonal (for \code{offset<0}).
\end{funcdesc}
\begin{funcdesc}{take}{matrix, indices, axis=0}
  Assembles an \class{Array} from the entries of the \class{Array}
  listed in \var{indices}, which must be simple numbers. \var{axis}
  specifies the axis along which the indices are taken.
\end{funcdesc}
\begin{funcdesc}{matrixmultiply}{op1, op2}
  Equivalent to \code{op1*op2}.
\end{funcdesc}
\begin{funcdesc}{innerproduct}{op1, op2}
  Equivalent to \code{op1*op2}.
\end{funcdesc}
\begin{funcdesc}{outerproduct}{op1, op2}
  Equivalent to \code{op1 <<outerproduct>> op2}.
\end{funcdesc}
\begin{funcdesc}{transpose}{op1}
  Equivalent to \code{op1.T}.
\end{funcdesc}
\begin{funcdesc}{hermite}{op1}
  Equivalent to \code{op1.H}.
\end{funcdesc}
\begin{funcdesc}{trace}{matrix, offset=0}
  Returns the sum of the \var{offset}th diagonal. See \function{diagonal}
  for details of the meaning of \var{offset}.
\end{funcdesc}
% --------------------------------------------------------------------------
\section{Elementary computations with matrices}
\class{Array}s support the operators \code{+} (binary), \code{+=},
\code{-} (binary), \code{-=}, as well as \code{+} (unary) and \code{-}
(unary) with their elementwise meanings as you would expect them.
Multiplication and division are also supplied, but have slightly more
intricate meanings, as discussed in Section
\ref{subsec:arraymultiplication}.

\subsection{Type promotion}
\label{subsec:arraypromotion}

If binary operators or ufuncs (see Section \ref{subsec:ufuncs})
are applied to arrays of non-matching flavor or typecode,
the operands are promoted to a common type. (For the case of
non-matching dimension, see Section \ref{subsec:arraybroadcast}
for broadcasting rules.)

If the only mismatch is in typecode, one argument array
is cast upward in the type hierarchy (e.g. from integer to real,
from real to complex) in order to match the other.

If there is also a mismatch in flavor, the matrix with the typecode
which is higher up in the type hierarchy determines the flavor of the
result.

\subsection{Broadcasting}
\label{subsec:arraybroadcast}

The binary elementwise operators as well as all the binary ufuncs (see
Section \ref{subsec:ufuncs}) accept argument pairs where one argument
has lesser dimension than the other. In this case, the missing dimensions
are \index{broadcasting}\dfn{broadcast} across the remainder of the
matrix. If the lesser-dimension argument is a scalar, this is easy to
explain: It is treated like an array of the right size filled with
that scalar. If it is a vector, it is treated like a matrix filled
with rows consisting of the given vector.

All of this can only work if the corresponding \class{Array} sizes 
match.

\subsection{Universal Functions}
\label{subsec:ufuncs}

PyLinear sports a few so-called \dfn{Universal Functions},
\indexii{Universal}{Function} some of which are \emph{unary},
while others are \emph{binary}. (The lengthy term universal function is
often abbreviated to \dfn{ufunc}\index{ufunc}.) Universal functions
generally apply a certain functionality to each element in an
array. For example, the \function{sin} universal function computes the
sine of each of the given array's entries, and returns the processed
matrix, which will be of the same size, flavor, and typecode. Binary
universal functions receive two \class{Array}s of equal size as
arguments, apply a binary function (such as, for example, addition or
multiplication) to each pair of entries of the two \class{Array}s,
pairing the entries at the same location in each \class{Array}, and
return an \class{Array} with the results. Binary universal functions
obey type promotion laws as laid out in section
\ref{subsec:arraypromotion}.

The following unary universal functions exist:

\begin{funcdesc}{conjugate}{array}
  Returns the complex-conjugate of the given \class{Array}. Simply
  copies real matrices.
\end{funcdesc}
\begin{funcdesc}{cos}{array}
  Returns the element-wise cosine of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{cosh}{array}
  Returns the element-wise hyperbolic cosine of the given
  \class{Array}.
\end{funcdesc}
\begin{funcdesc}{exp}{array}
  Returns the element-wise natural exponential of the given
  \class{Array}. 

  \emph{WARNING:} This is not matrix exponentiation.
\end{funcdesc}
\begin{funcdesc}{log}{array}
  Returns the element-wise natural logarithm of the given
  \class{Array}.
\end{funcdesc}
\begin{funcdesc}{log10}{array}
  Returns the element-wise base-10 logarithm of the given
  \class{Array}.
\end{funcdesc}
\begin{funcdesc}{sin}{array}
  Returns the element-wise sine of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{sinh}{array}
  Returns the element-wise hyperbolic sine of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{sqrt}{array}
  Returns the element-wise square root of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{tan}{array}
  Returns the element-wise tangent of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{tanh}{array}
  Returns the element-wise hyperbolic tangent of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{floor}{array}
  Returns the element-wise floor of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{ceil}{array}
  Returns the element-wise ceiling of the given \class{Array}.
\end{funcdesc}
\begin{funcdesc}{argument}{array}
  Returns the element-wise complex argument of the given \class{Array}.
  Resulting matrix consists of values of zero and $\pi$ for real matrices.
\end{funcdesc}
\begin{funcdesc}{absolute}{array}
  Returns the element-wise absolute value of the given \class{Array}.
\end{funcdesc}

The following binary universal functions exist:

\begin{funcdesc}{add}{op1, op2}
  Returns the element-wise sum of the given \class{Array}s. Obeys
  broadcasting (see Section \ref{subsec:arraybroadcasting}) and type
  promotion (see Section \ref{subsec:arraypromotion}) laws.

  Equivalent to the \code{+} operator.
\end{funcdesc}
\begin{funcdesc}{subtract}{op1, op2}
  Returns the element-wise difference of the given \class{Array}s. Obeys
  broadcasting (see Section \ref{subsec:arraybroadcasting}) and type
  promotion (see Section \ref{subsec:arraypromotion}) laws.

  Equivalent to the \code{-} operator.
\end{funcdesc}
\begin{funcdesc}{multiply}{op1, op2}
  Returns the element-wise product of the given \class{Array}s. Obeys
  broadcasting (see Section \ref{subsec:arraybroadcasting}) and type
  promotion (see Section \ref{subsec:arraypromotion}) laws.

  \emph{NOT} equivalent to the \code{*} operator, except in the scalar
  case.
\end{funcdesc}
\begin{funcdesc}{divide}{op1, op2}
  Returns the element-wise quotient of the given \class{Array}s. Obeys
  broadcasting (see Section \ref{subsec:arraybroadcasting}) and type
  promotion (see Section \ref{subsec:arraypromotion}) laws.

  \emph{NOT} equivalent to the \code{/} operator, except in the scalar
  case.
\end{funcdesc}
\begin{funcdesc}{power}{op1, op2}
  Returns the element-wise power \code{op1[i]**op2[i]} of the given
  \class{Array}s. Obeys broadcasting (see Section
  \ref{subsec:arraybroadcasting}) and type promotion (see Section
  \ref{subsec:arraypromotion}) laws.

  \emph{NOT} equivalent to the \code{**} operator, except in the scalar
  case.
\end{funcdesc}
\begin{funcdesc}{maximum}{op1, op2}
  Returns the element-wise maximum of the given
  \class{Array}s. Obeys broadcasting (see Section
  \ref{subsec:arraybroadcasting}) and type promotion (see Section
  \ref{subsec:arraypromotion}) laws.

  For complex matrices, the maximum is found based on the real part.
\end{funcdesc}
\begin{funcdesc}{minimum}{op1, op2}
  Returns the element-wise minimum of the given
  \class{Array}s. Obeys broadcasting (see Section
  \ref{subsec:arraybroadcasting}) and type promotion (see Section
  \ref{subsec:arraypromotion}) laws.

  For complex matrices, the minimum is found based on the real part.
\end{funcdesc}

Additional universal function methods, such as \member{reduce}, as they are
found in NumPy, are not (yet) supported in PyLinear.

\subsection{Multiplication semantics}
\label{subsec:arraymultiplication}

This section explains what the value of \code{a*b} is, where at least
one of \code{a} and \code{b} is an \class{Array}.

If the other operand is a scalar (it doesn't matter which), the
result will be the element-wise product of the array with that scalar.

If both operands are \class{Vector}s, \code{a*b} computes the inner
product of both vectors. Note that in the complex case no complex
conjugates are taken. If you require them, use the expression
\code{a*b.H}.

If \code{a} is a \class{Vector} and \code{b} is a \class{Matrix},
\code{a*b} will result in $b^Ta$, using the conventional matrix-vector
product.

If \code{a} is a \class{Matrix} and \code{b} is a \class{Vector},
\code{a*b} will result in $a b$, using the conventional matrix-vector
product.

If both \code{a} and \code{b} are \class{Matrix} types,
\code{a*b} will result in $a b$, using the conventional matrix-matrix
product.

All these explanations also apply to the inplace multiplication
operator \code{*=}.

All multiplication operators obey type promotion rules as laid out
in Section \ref{subsec:arraypromotion}.

\subsection{Other \class{Array} operators}

The following expressions are also valid:
\begin{itemize} 
\item \code{matrix**n}

  Computes the \var{n}th power of \var{matrix}. \var{n} must be
  integer, but may be negative. Only for dense matrices.

\item \code{scalar/matrix}

  Computes the \var{scalar} multiple of the inverse of
  \var{matrix}. Only for dense matrices.

  Do not use code like \code{1/a*x} to solve linear systems of
  equations; besides being slow, this tends to yield imprecise
  results. Instead, use the \code{<<solve>>} pseudo-operator.

  Use of this operator will fail unless the module
  \module{pylinear.operation} is available.

\item \code{matrix <<solve>> vector}

  Returns the solution of the linear system of equations \code{matrix*x=vector}.
  Available for dense and sparse execute matrix types of \var{matrix}.

  Use of this operator will fail unless the module
  \module{pylinear.operation} is available.

\item \code{vector1 <<outer>> vector2}
  
  Computes the outer product of \code{vector1} and \code{vector2}.
\end{itemize}
